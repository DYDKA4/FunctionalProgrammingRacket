3.I
Объектно-ориентированном программировании в Scheme состоит из состояний и функций:
У функций есть
	- параметры и тело описанные в lambda-выражении
	- окружение, где хранятся связывания её имён
Можно использовать функцию для хранения (и сокрытия) данных в локальных 
переменных и предоставления доступа к ним.
При вызове функции-конструктора создаётся новое окружение.
Нужно иметь доступ из функции-объекта к этому окружению:
	- для чтения нужны операции-селекторы (или геттеры);
	- для изменения состояния нужны мутаторы;
	- состояние - это текущие связывания в кадре, созданном при вызове конструктора
Пример описания нетривиального класса на Scheme
(define (create-place name)
	(let ((things '()))
		(lambda (msg . msg-args)
			(cond ((eq? msg 'get-name) name)
				((eq? msg 'get-things) things)
				((eq? msg 'put-thing!) (set! things (cons (car msg-args) things)))
				(else (error "WRONG MESSAGE"))))))
Пример описания нетривиального класса на Racket
(define place%
	(class object%
		(super-new)
		(init-field name)
		(field (things '()))
		(define/public (get-name) name)
		(define/public (get-things) things)
		(define/public (put-thing! thing) (set! things (cons thing things)))
))
Преимущества:
	- Модульность
	- Гибкость, код лешче дополнять и понимать
3.II
Если в ходе процесса появляется цепочка отложенных вычислений, то такой процесс рекурсивный.
Если в ходе процесса отложенных вычислений нет, то такой процесс итеративный
Рекурсивный:
(define (summ-lst list)
  (if (eq? '() (cdr list))
      (car list)
      (+ (car list) (summ-lst (cdr list)))
      )
  )
Итеративный:
(define (summ-lst-iter list)
  (let sub ((result 0) (list list))
    (if (eq? '() (cdr list))
        (+ result (car list))
        (sub (+ result (car list)) (cdr list))
        ))
  )
Описание итеративного процесса больше, однако с прагматичной точки зрения, в резульате работы такой программы, 
не возникают остаточные вычисления, из-за этого требуется меньше оперативной памяти.
3.III
Закрытость. Макросистема отделена от Scheme. Во время подстановки нельзя запустить какой-либо код или использовать какое-то значение.
Гигиена. Макрос не портит непредсказуемым образом окружения, в которых происходит подстановка.
Прозрачность ссылок. Окружение, в котором происходит подстановка не портит макрос.
Язык образцов и язык шаблонов используются для описания структуры макрокоманд и «тел» макросов, соответственно.

Использование макросов, допустимо в тех случиях, когда мы не можем реализовать то, что нам требует с использхованием стандартных механизмов. 
Когда может потребоваться макрос: 
	- условные вычисления (cond, if, case и т.д.)
	- связывания (аналоги set!, let, let* и т.д.)
	- изменение порядка вычисления
Пример: 
(define (swap! x y)
 (let ((c x)) (set! x y) (set! y c)))
Такая программа не будет работать.
Напишем макрос, который будет работать 
(define-syntax swap
	(syntax-rules ()
		((swap a b)
			(let ((c b))
			(set! b a)
			(set! a c))
)))

2. Укажите только верные утверждения относительно (set! a b)
	-с. set! вычисляет лишь один из своих аргументов
	-e. до вычисления (set! a b) в одном из кадров текущего окружения обязательно должно быть связывание a
3. Пусть есть определения:
	(define a '(0 1 2 3))
	(define b (append (list 0 1 2) (cdddr a)))
Укажите те и только те выражения, которые истинны.
	-a. (equal? a b)
	-b. (= (car a) (car b))
	-c. (eq? (cadr a) (cadr b))
	-g. (= (caddr a) (caddr b))
4. Пусть lst – список. Укажите все выражения, значения которых всегда равны значению выражения (<= (length lst) 1)
	-c. (cond ((null? lst) #t) (else (null? (cdr lst))))
5.Укажите те и только те утверждения, которые верны.

6. Программы
7.Укажите те и только те утверждения, которые не верны для макросов системы syntax-rules.
	-b. Макросом нельзя описать собственную специальную форму.
	-c. При использовании макроса сначала вычисляются некоторые его аргументы.
	-d. При использовании макроса никакие его аргументы не вычисляются.
8. Укажите всё то, что верно описывает вычисление выражения (if (or) (delay (quotient 7 2)) (delay (/ 1 0))), где delay -- спецформа, описанная в лекции 8.
	-a. Результатом будет #<promise> -- обещание поделить на 0. Это так, поскольку результат (or) -- #f. Значит, сработает вторая ветка if.
9. Укажите всё то, что верно описывает вычисление выражения ((lambda (a b c) (if a b c)) (quotient 7 2) (/ 1 0) (and))
	-f. Результатом вычисления будет ошибка, так как при вычислении комбинации сначала вычисляются все её подвыражения. Из-за этого интерпретатор попытается поделить на 0, что и приведёт к ошибке.
10. Укажите те и только те утверждения, которые верны.
	-a. если у λ-выражения существует нормальная форма, то она единственна с точностью до α-редукции
	-g. если у λ-выражения существует нормальная форма, то она единственна с точностью до переименования связанных переменных
	-h. к λ-выражению в нормальной форме никакая λ-редукция не может быть применена
11. Укажите наиболее полный список того, что может быть явно представлено на UML-диаграммах классов, исключая то, что может быть представлено на UML-диаграммах объектов.
	-c. классы, интерфейсы, атрибуты, операции, экземпляры классов, связи: ассоциации, обобщения, реализации, соединения экземпляров классов
12. Укажите всё то, что верно объясняет вычисление выражения (let ((a 3) (b 6)) (begin ((lambda (b a) (set! a (- b a))) b a) (- b a)))
	-a. Результатом будет 3, так как set манипулирует локальными именами анонимной функции, а значит, не меняет a из let.